[{"title":"Scala修饰符","date":"2019-10-24T02:29:00.000Z","path":"2019/10/24/【Scala】修饰符/","text":"Scala 访问修饰符基本和Java的一样，分别有：private，protected，public。但是一些细节不太一样。默认缺省情况下，Scala对象的访问级别是public。 不写（default）默认：包内可访问 private私有：类内可访问 protected保护：包内和子类可访问 public公有：都可访问 私有private 带有此标记的成员仅在包含了成员定义的类或对象内部可见。他们不能被子类继承，也不能覆盖父类中的定义 Scala中 123456789101112131415class ScalaOuter &#123; class ScalaInner &#123; private def hello() &#123; println(&quot;hello&quot;) &#125; class ScclaInnerInner &#123; hello() &#125; &#125; private def world(): Unit = &#123; (new ScalaInner).hello() //错误，方法不可见 &#125;&#125; Java中 123456789101112131415161718class JavaOuter &#123; class JavaInner &#123; private void hello() &#123; System.out.println(&quot;hello&quot;); &#125; class JavaInnerInner &#123; private void world() &#123; hello(); &#125; &#125; &#125; private void world() &#123; // Java中能够访问 new JavaInner().hello(); &#125;&#125; 保护protected 只允许保护成员在定义了该成员的的类的子类中被访问。而在Java中，用protected关键字修饰的成员，除了定义了该成员的类的子类可以访问，同一个包里的其他类也可以进行访问 Scala中 12345678910111213141516171819202122232425package a &#123; class ScalaOuter &#123; protected val helloWorld = &quot;Hello World&quot; protected def hello() &#123; println(&quot;hello&quot;) &#125; class ScalaInner &#123; hello() &#125; &#125;&#125;package b &#123; class ScalaOuterChild extends a.ScalaOuter &#123; hello() private def world(): Unit = &#123; hello() println(helloWorld) &#125; &#125;&#125; Java中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package a;public class JavaOuter &#123; protected String helloWorld = &quot;Hello World&quot;; protected void hello() &#123; System.out.println(&quot;hello&quot;); &#125;&#125;/* 子类中能和谐访问 */package b;import a.JavaOuter;public class JavaOuterChild extends JavaOuter &#123; private void world() &#123; this.hello(); System.out.println(helloWorld); &#125;&#125;/* 同一个包中，能和谐访问 */package a;public class JavaOuterSamePackage &#123; private void world() &#123; JavaOuter outer = new JavaOuter(); // 正常访问 outer.hello(); // 正常访问 System.out.println(outer.helloWorld); &#125;&#125;/* 不同包中，不能访问 */package b;import a.JavaOuter;public class JavaOuterDiffPackage &#123; private void world() &#123; JavaOuter outer = new JavaOuter(); // 不能访问 outer.hello(); // 不能访问 System.out.println(outer.helloWorld); &#125;&#125; 公共public 如果没有指定任何的修饰符，则默认为 public。这样的成员在任何地方都可以被访问 作用域保护 1、Scala访问修饰符可以通过使用限定词强调，private[x]：这个成员除了对[…]中的类或[…]中的包中的类及他们的伴生对象可见外，对其他的类都是private。 2、有了这个，可以针对一些private对象跨包访问 3、private[x]其中x可以是包也可以是类 4、private[this]比较特殊，只能从该成员定义的对象内访问 123private[x] 或 protected[x] 修饰类与伴生对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package demo.a &#123; import demo.a.b.&#123;PrivateUser, PrivateUserA, PrivateUserA_B&#125; package b &#123; /** * package demo.a中可见 */ private[a] class PrivateUserA &#123; &#125; /** * package demo.a.b中可见 */ private[b] class PrivateUserA_B &#123; &#125; /** * 没有指定，默认所在包package demo.a.b中可见 */ private class PrivateUser &#123;&#125; class Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() // 正常访问 val userB: PrivateUserA_B = new PrivateUserA_B() // 正常访问 val user: PrivateUser = new PrivateUser() &#125; object Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() // 正常访问 val userB: PrivateUserA_B = new PrivateUserA_B() // 正常访问 val user: PrivateUser = new PrivateUser() &#125; &#125; class Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() // 不能访问 val userB: PrivateUserA_B = new PrivateUserA_B() // 不能访问 val user: PrivateUser = new PrivateUser() &#125; object Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() // 不能访问 val userB: PrivateUserA_B = new PrivateUserA_B() // 不能访问 val user: PrivateUser = new PrivateUser() &#125; package c &#123; import demo.a.b.&#123;PrivateUser, PrivateUserA, PrivateUserA_B&#125; class Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() // 不能访问 val userB: PrivateUserA_B = new PrivateUserA_B() // 不能访问 val user: PrivateUser = new PrivateUser() &#125; object Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() // 不能访问 val userB: PrivateUserB = new PrivateUserB() // 不能访问 val user: PrivateUser = new PrivateUser() &#125; &#125;&#125; 修饰方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package demo.a &#123; import demo.a.b.&#123;PrivateUser, PrivateUserA, PrivateUserA_B&#125; package b &#123; /** * package demo.a中可见 */ private[a] class PrivateUserA &#123; private[a] def sayHelloA(text: String): Unit = &#123; println(text) &#125; private[b] def sayHelloA_B(text: String): Unit = &#123; println(text) &#125; &#125; /** * package demo.a.b中可见 */ private[b] class PrivateUserA_B &#123; private[a] def sayHelloA(text: String): Unit = &#123; println(text) &#125; private[b] def sayHelloA_B(text: String): Unit = &#123; println(text) &#125; &#125; /** * 没有指定，默认所在包package demo.a.b中可见 */ private class PrivateUser &#123; private[a] def sayHelloA(text: String): Unit = &#123; println(text) &#125; private[b] def sayHelloA_B(text: String): Unit = &#123; println(text) &#125; &#125; class Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() userA.sayHelloA(&quot;helloA&quot;) userA.sayHelloA_B(&quot;helloB&quot;) // 正常访问 val userB: PrivateUserA_B = new PrivateUserA_B() userB.sayHelloA(&quot;helloA&quot;) userB.sayHelloA_B(&quot;helloB&quot;) // 正常访问 val user: PrivateUser = new PrivateUser() user.sayHelloA(&quot;helloA&quot;) user.sayHelloA_B(&quot;helloB&quot;) &#125; object Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() userA.sayHelloA(&quot;helloA&quot;) userA.sayHelloA_B(&quot;helloB&quot;) // 正常访问 val userB: PrivateUserA_B = new PrivateUserA_B() userB.sayHelloA(&quot;helloA&quot;) userB.sayHelloA_B(&quot;helloB&quot;) // 正常访问 val user: PrivateUser = new PrivateUser() user.sayHelloA(&quot;helloA&quot;) user.sayHelloA_B(&quot;helloB&quot;) &#125; &#125; class Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() userA.sayHelloA(&quot;helloA&quot;) //不能访问 userA.sayHelloA_B(&quot;helloB&quot;) // 不能访问 val userB: PrivateUserA_B = new PrivateUserA_B() userB.sayHelloA(&quot;helloA&quot;) userB.sayHelloA_B(&quot;helloB&quot;) // 不能访问 val user: PrivateUser = new PrivateUser() user.sayHelloA(&quot;helloA&quot;) user.sayHelloA_B(&quot;helloB&quot;) &#125; object Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() userA.sayHelloA(&quot;helloA&quot;) //不能访问 userA.sayHelloA_B(&quot;helloB&quot;) // 不能访问 val userB: PrivateUserA_B = new PrivateUserA_B() userB.sayHelloA(&quot;helloA&quot;) userB.sayHelloA_B(&quot;helloB&quot;) // 不能访问 val user: PrivateUser = new PrivateUser() user.sayHelloA(&quot;helloA&quot;) user.sayHelloA_B(&quot;helloB&quot;) &#125; package c &#123; import demo.a.b.&#123;PrivateUser, PrivateUserA, PrivateUserA_B&#125; class Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() userA.sayHelloA(&quot;helloA&quot;) //不能访问 userA.sayHelloA_B(&quot;helloB&quot;) // 不能访问 val userB: PrivateUserA_B = new PrivateUserA_B() userB.sayHelloA(&quot;helloA&quot;) userB.sayHelloA_B(&quot;helloB&quot;) // 不能访问 val user: PrivateUser = new PrivateUser() user.sayHelloA(&quot;helloA&quot;) user.sayHelloA_B(&quot;helloB&quot;) &#125; object Hello &#123; // 正常访问 val userA: PrivateUserA = new PrivateUserA() userA.sayHelloA(&quot;helloA&quot;) //不能访问 userA.sayHelloA_B(&quot;helloB&quot;) // 不能访问 val userB: PrivateUserA_B = new PrivateUserA_B() userB.sayHelloA(&quot;helloA&quot;) userB.sayHelloA_B(&quot;helloB&quot;) // 不能访问 val user: PrivateUser = new PrivateUser() user.sayHelloA(&quot;helloA&quot;) user.sayHelloA_B(&quot;helloB&quot;) &#125; &#125;&#125;","tags":[{"name":"修饰符","slug":"修饰符","permalink":"https://ceclar123.github.io/tags/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"}]},{"title":"Scala数据类型","date":"2019-10-23T12:29:00.000Z","path":"2019/10/23/【Scala】数据类型/","text":"Scala完全面向对象语法，像Java中的基本数据类型（例如：int）是没有。同时Java的包装类型（例如：Integer）在Scala中都有对应的类型，并且可以隐式转换。 数据类型 数据类型 描述 Byte 8位有符号补码整数。数值区间为 -128 到 127 Short 16位有符号补码整数。数值区间为 -32768 到 32767 Int 32位有符号补码整数。数值区间为 -2147483648 到 2147483647 Long 64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807 Float 32 位, IEEE 754 标准的单精度浮点数 Double 64 位 IEEE 754 标准的双精度浮点数 Char 16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF String 字符序列 Boolean true或false Unit 表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。 Null Null类是null引用对象的类型，它是每个引用类（继承自AnyRef的类）的子类。Null不兼容值类型 Nothing Nothing类型在Scala的类层级的最底端；它是任何其他类型的子类型。 Any Any是所有其他类的超类 AnyRef AnyRef类是Scala里所有引用类(reference class)的基类 AnyVal AnyVal是Scala里所有值类型的基类 类关系 Any AnyVal Byte Short Int Long Float Double Unit Char Boolean Scala.Nothing AnyRef Scala.Null Scala.Nothing 字面量 整形字面量 整型字面量用于 Int 类型，如果表示 Long，可以在数字后面添加 L 或者小写 l 作为后缀。Byte、Short需要显示声明并且不要越界。 Scala不支持八进制字面量和以0开头的整数字面量 1234567891011121314151617val age1 = 1val age2 = 1Lval age3 = 0x1254512val age4 = 0x1254512Lval age5: Short = 100val age6: Byte = 12println(age1.getClass, age1)println(age2.getClass, age2)println(age3.getClass, age3)println(age4.getClass, age4)println(age5.getClass, age5)println(age6.getClass, age6)printf(&quot;Byte[%d,%d]\\n&quot;, Byte.MinValue, Byte.MaxValue)printf(&quot;Short[%d,%d]\\n&quot;, Short.MinValue, Short.MaxValue)printf(&quot;Int[%d,%d]\\n&quot;, Int.MinValue, Int.MaxValue)printf(&quot;Long[%d,%d]\\n&quot;, Long.MinValue, Long.MaxValue) 浮点型字面量 浮点型默认是Double类型，Float类型需要在数字后面加后缀F 12345678val price1 = 12.34val price2 = 12.34Fprintln(price1.getClass, price1)println(price2.getClass, price2)printf(&quot;Float[%f,%f]\\n&quot;, Float.MinValue, Float.MaxValue)printf(&quot;Double[%f,%f]\\n&quot;, Double.MinValue, Double.MaxValue) 布尔型字面量 12345val b1 = trueval b2 = falseprintln(b1.getClass, b1)println(b2.getClass, b2) 符号字面量 符号字面量被写成： ‘&lt;标识符&gt; ，这里 &lt;标识符&gt; 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例 属于基本类型，被映射成scala.Symbol 当两个Symbol值相等时，指向同一个实例 作为不可变的字符串，同时不必重复地为相同对象创建实例，节省资源 123456val s1 = &#x27;helloval s2 = scala.Symbol(&quot;hello&quot;)println(s1 == s2)println(s1.getClass, s1)println(s2.getClass, s2) 字符字面量 用单引号**’**来操作 12345678910111213val ch1 = &#x27;a&#x27;val ch2 = &#x27;\\u0041&#x27;val ch3 = &#x27;\\n&#x27;val ch4 = &#x27;\\t&#x27;val ch5 = &#x27;\\f&#x27;val ch6: Char = 97println(ch1.getClass, ch1)println(ch2.getClass, ch2)println(ch3.getClass, ch3)println(ch4.getClass, ch4)println(ch5.getClass, ch5)println(ch6.getClass, ch6) 字符串字面量 用双引号**”表示，多行字符串用三引号“””**表示 1234567val str1 = &quot;hello wolrd&quot;val str2 = &quot;&quot;&quot;hello 多行文本, 第二行文本， 第三行文本&quot;&quot;&quot;println(str1.getClass, str1)println(str2.getClass, str2) 转义字符 转义字符 Unicode 描述 \\b \\u0008 退格(BS) ，将当前位置移到前一列 \\t \\u0009 水平制表(HT) （跳到下一个TAB位置） \\n \\u000a 换行(LF) ，将当前位置移到下一行开头 \\f \\u000c 换页(FF)，将当前位置移到下页开头 \\r \\u000d 回车(CR) ，将当前位置移到本行开头 &quot; \\u0022 代表一个双引号(“)字符 &#39; \\u0027 代表一个单引号（’）字符 \\ \\u005c 代表一个反斜线字符 ‘&#39;","tags":[{"name":"数据类型","slug":"数据类型","permalink":"https://ceclar123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"Scala变量","date":"2019-10-21T03:29:00.000Z","path":"2019/10/21/【Scala】变量/","text":"在 Scala 中，使用关键词 var 声明变量，使用关键词 val 声明常量 变量声明 12var VariableName : DataType [&#x3D; Initial Value]val VariableName : DataType [&#x3D; Initial Value] 123var city: String = &quot;北京&quot;val age: Int = 10println(city, age) 类型推断 当分配一个初始值给一个变量，Scala编译器可以计算出根据分配给它的值的变量类型。 123var city1 = &quot;北京&quot;val city2 = &quot;上海&quot;println(city1, city2) 多个变量声明12345var city1, city2 = &quot;北京&quot;println(city1, city2)val user1, user2 = &quot;张三&quot;println(user1, user2) 变量与常量12345678910111213141516171819202122232425// var变量var city = &quot;北京&quot;city = &quot;上海&quot;println(city)// val常量val user = &quot;张三&quot;// 不能重新赋值//user = &quot;李四&quot;println(user)// 有一种特殊场景，虽然不能重新对val变量userInfo赋值，但是可以修改里面的内容class UserInfo(var userName: String, var age: Int) &#123; override def toString: String = &#123; s&quot;$&#123;userName&#125;,$&#123;age&#125;&quot; &#125;&#125;val userInfo: UserInfo = new UserInfo(&quot;李四&quot;, 20)// 不能重新赋值//userInfo = new UserInfo(&quot;李四&quot;, 20)//修改内容userInfo.userName = &quot;张三&quot;userInfo.age = 10println(userInfo)","tags":[{"name":"变量","slug":"变量","permalink":"https://ceclar123.github.io/tags/%E5%8F%98%E9%87%8F/"}]},{"title":"Scala基础","date":"2019-10-20T06:29:00.000Z","path":"2019/10/20/【Scala】基础/","text":"Scala是一种纯面向对象的语言，每个值都是对象。基于JVM，兼容现有的Java程序。对于有Java基础的很容易掌握，同时有一些细节也需要特别关注。 注意事项 大小写敏感，与Java一样 类名，首字母大写，单词首字母大写，与Java一样 123class HelloWorld &#123; //&#125; 方法名称，首字母小写，单词首字母大写，与Java一样 12345class HelloWorld &#123; def sayHello(txt: String): Unit = &#123; println(s&quot;hello $&#123;txt&#125;&quot;) &#125;&#125; 文件名称，程序文件的名称应该与对象名称完全匹配(新版本不需要了) 标识符 用于对象，类，变量和方法的名称称为标识符。关键字不能用作标识符，标识符区分大小写。 字母数字标识符 以字母或下划线开始，之后可以跟字母、数字或下划线 $字符也被当作是字母，但被保留作为scala编译器产生的标识符之用。用户程序里的标识符不应该包含$字符，尽管能够编译通过，最好不要这样用 Scala遵循java的驼峰式标识符习惯，尽管下划线在标识符内是合法的，但最好不要这样用，因为在Scala中有其他用法。 运算符标识符 由一个或多个符号组成，例如： 1+ ++ ::: &lt; ?&gt; :-&gt; Scala编译器将在内部将操作符标识符转换成具有嵌入式$字符的合法Java标识符。例如，标识符:-&gt;将被内部表示为$colon$minus$greater 混合标识符 由字母数字组成，后面跟着下划线和一个操作符标识符 123val user_+ = &quot;张三&quot;val user_# = &quot;李四&quot;println(user_+, user_#) 字面识别符 文字标识符是用反引号`括起来的任意字符串，即使scala保留字，这个规则也有效 1234val `province` = &quot;四川&quot;val `object` = &quot;成都&quot;println(`province`, `object`)// 在 Scala 中 Thread. yield()非法的，因为 yield 是保留字。但是可以这样调用：Thread.`yield`() 注释 与Java类似，支持单行与多行注释，多行注释注意嵌套 1234567891011121314151617/** 这里是多行注释* /*多行注意嵌套*/*/val hello = &quot;hello&quot;// 单行注释1// 单行注释2var world = &quot;world&quot;/*** 文档注释** @param args 参数*/def main(args: Array[String]): Unit = &#123; //&#125; 换行符 Scala是面向行的语言，语句可以用分号（;）结束或换行符 语句末尾的分号通常是可选的。如果一行里仅 有一个语句可不写。如果一行里写多个语句那么分号是必需的 12val a = &quot;张三&quot;val b = &quot;张三&quot;; val c = &quot;李四&quot; 关键字 abstract case catch class def do else extends false final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try true type val var while with yield - : = =&gt; &lt;- &lt;: &lt;% &gt;: # @","tags":[{"name":"语法","slug":"语法","permalink":"https://ceclar123.github.io/tags/%E8%AF%AD%E6%B3%95/"},{"name":"基础","slug":"基础","permalink":"https://ceclar123.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"对象相等比较","date":"2019-08-21T12:01:00.000Z","path":"2019/08/21/【Scala】对象相等比较/","text":"在 Scala 中，可以直接使用JDK的类库，好多功能语法相似，在Java中比较对象就用==与equals很简单。在Scala中可以使用==、equals、eq、sameElements 比较规则 Java中比较引用或则基本数据类型用==，比较内容用equals方法 Scala中直接使用==，内部首先判断左侧是否为null，如果不为null，直接调用equals方法，当然也可以调用equals方法 Scala中如果要特别比较引用相等性可以用eq与ne方法，这个跟Java中的==一直 https://www.scala-lang.org/api/current/scala/AnyRef.html final def==(arg0: Any): Boolean The expression x == that is equivalent to if (x eq null) that eq null else x.equals(that). 如果x为null就that.eq(null)，如果x不为null就x.equals(that) final def eq(arg0: AnyRef): Boolean Tests whether the argument (that) is a reference to the receiver object (this). def equals(arg0: AnyRef): Boolean The equality method for reference types. Java举例1234567891011121314151617181920212223242526272829303132333435363738394041class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (!(o instanceof Person)) &#123; return false; &#125; Person person = (Person) o; return name.equals(person.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name); &#125;&#125;public static void main(String[] args) &#123; Person p1 = new Person(&quot;张三&quot;); Person p2 = new Person(&quot;张三&quot;); //引用比较 System.out.printf(&quot;p1 == p2 -&gt; %s\\r\\n&quot;, p1 == p2); System.out.printf(&quot;p1 != p2 -&gt; %s\\n&quot;, p1 != p2); //内容比较 System.out.printf(&quot;p1.equals(p2) -&gt; %s\\n&quot;, p1.equals(p2));&#125;/*输出结果:p1 == p2 -&gt; falsep1 != p2 -&gt; truep1.equals(p2) -&gt; true*/ Scala举例123456789101112131415161718192021222324252627282930313233343536class Person(val name: String) &#123; private def canEqual(other: Any): Boolean = other.isInstanceOf[Person] override def equals(other: Any): Boolean = other match &#123; case that: Person =&gt; (that canEqual this) &amp;&amp; name == that.name case _ =&gt; false &#125; override def hashCode(): Int = &#123; val state = Seq(name) state.map(_.hashCode()).foldLeft(0)((a, b) =&gt; 31 * a + b) &#125;&#125;def main(args: Array[String]): Unit = &#123; val p1 = new Person(&quot;张三&quot;) val p2 = new Person(&quot;张三&quot;) //内容比较 printf(&quot;p1 == p2 -&gt; %s\\r\\n&quot;, p1 == p2) printf(&quot;p1 != p2 -&gt; %s\\r\\n&quot;, p1 != p2) printf(&quot;p1.equals(p2) -&gt; %s\\r\\n&quot;, p1.equals(p2)) //引用比较 printf(&quot;p1.eq(p2) -&gt; %s\\r\\n&quot;, p1.eq(p2)) printf(&quot;p1.ne(p2) -&gt; %s\\r\\n&quot;, p1.ne(p2)) &#125; /*输出结果:p1 == p2 -&gt; truep1 != p2 -&gt; falsep1.equals(p2) -&gt; truep1.eq(p2) -&gt; falsep1.ne(p2) -&gt; true*/ Scala中使用Java类库注意事项123456789101112131415def main(args: Array[String]): Unit = &#123; val i1 = new java.lang.Integer(Int.MaxValue) val l1 = new java.lang.Long(Int.MaxValue) # 这里比较特殊 printf(&quot;i1 == l1 -&gt;%s\\r\\n&quot;, i1 == l1) printf(&quot;i1.equals(l1) -&gt;%s\\r\\n&quot;, i1.equals(l1)) printf(&quot;i1.eq(l1) -&gt;%s\\r\\n&quot;, i1.eq(l1))&#125; /*输出结果:i1 == l1 -&gt;truei1.equals(l1) -&gt;falsei1.eq(l1) -&gt;false*/ Scala集合中可能需要使用sameElements比较内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def main(args: Array[String]): Unit = &#123; //List推荐使用equals与eq val list1 = List(&quot;北京&quot;, &quot;上海&quot;) val list2 = List(&quot;北京&quot;, &quot;上海&quot;) printf(&quot;list1 == list2 -&gt; %s\\r\\n&quot;, list1 == list2) printf(&quot;list1.equals(list2) -&gt; %s\\r\\n&quot;, list1.equals(list2)) printf(&quot;list1.sameElements(list2) -&gt; %s\\r\\n&quot;, list1.sameElements(list2)) printf(&quot;list1.eq(list2) -&gt; %s\\r\\n&quot;, list1.eq(list2)) //Array推荐使用sameElements与eq val array1 = Array(&quot;北京&quot;, &quot;上海&quot;) val array2 = Array(&quot;北京&quot;, &quot;上海&quot;) printf(&quot;array1 == array2 -&gt; %s\\r\\n&quot;, array1 == array2) printf(&quot;array1.equals(array2) -&gt; %s\\r\\n&quot;, array1.equals(array2)) printf(&quot;array1.sameElements(array2) -&gt; %s\\r\\n&quot;, array1.sameElements(array2)) printf(&quot;array1.eq(array2) -&gt; %s\\r\\n&quot;, array1.eq(array2)) //Map推荐使用equals与eq val map1 = Map(&quot;北京&quot; -&gt; 1, &quot;上海&quot; -&gt; 1) val map2 = Map(&quot;北京&quot; -&gt; 1, &quot;上海&quot; -&gt; 1) printf(&quot;map1 == map2 -&gt; %s\\r\\n&quot;, map1 == map2) printf(&quot;map1.equals(map2) -&gt; %s\\r\\n&quot;, map1.equals(map2)) printf(&quot;map1.sameElements(map2) -&gt; %s\\r\\n&quot;, map1.sameElements(map2)) printf(&quot;map1.eq(map2) -&gt; %s\\r\\n&quot;, map1.eq(map2)) //Set推荐使用equals与eq val set1 = Set(&quot;北京&quot;, &quot;上海&quot;) val set2 = Set(&quot;北京&quot;, &quot;上海&quot;) printf(&quot;set1 == set2 -&gt; %s\\r\\n&quot;, set1 == set2) printf(&quot;set1.equals(set2) -&gt; %s\\r\\n&quot;, set1.equals(set2)) printf(&quot;set1.sameElements(set2) -&gt; %s\\r\\n&quot;, set1.sameElements(set2)) printf(&quot;set1.eq(set2) -&gt; %s\\r\\n&quot;, set1.eq(set2))&#125;/*输出结果:list1 == list2 -&gt; truelist1.equals(list2) -&gt; truelist1.sameElements(list2) -&gt; truelist1.eq(list2) -&gt; falsearray1 == array2 -&gt; falsearray1.equals(array2) -&gt; falsearray1.sameElements(array2) -&gt; truearray1.eq(array2) -&gt; falsemap1 == map2 -&gt; truemap1.equals(map2) -&gt; truemap1.sameElements(map2) -&gt; truemap1.eq(map2) -&gt; falseset1 == set2 -&gt; trueset1.equals(set2) -&gt; trueset1.sameElements(set2) -&gt; trueset1.eq(set2) -&gt; false*/","tags":[{"name":"相等","slug":"相等","permalink":"https://ceclar123.github.io/tags/%E7%9B%B8%E7%AD%89/"}]},{"title":"Scala控制结构","date":"2019-08-10T07:29:00.000Z","path":"2019/08/10/【Scala】控制结构/","text":"if表达式 Scala 语言的if的基本功能和其它语言没有什么不同。但是在Scala中的if-else语句是可以有返回值的，可以用来做为赋值语句。 传统分支场景 123456val name = &quot;张三&quot;if (Objects.equals(&quot;张三&quot;, name)) &#123; System.out.println(&quot;----if-&gt;&quot; + name)&#125; else &#123; System.out.println(&quot;----else-&gt;&quot; + name)&#125; 返回值场景 1234567val name = &quot;张三&quot;val hello = if (Objects.equals(&quot;张三&quot;, name)) &#123; &quot;if-&quot; + name&#125; else &#123; &quot;else-&quot; + name&#125;System.out.println(hello) while循环 在Scala中也支持do-while，并且while-do 和 do-while 称为“循环”而不是表达式，是因为它不产生有用的返回值（或是返回值为 Unit) while-do场景 123456var str = &quot;&quot;while (!&quot;#&quot;.equals(str)) &#123; System.out.println(str) str = StdIn.readLine()&#125;System.out.println(&quot;****game over****&quot;) do-while场景 123456var str = &quot;&quot;do &#123; System.out.println(str) str = StdIn.readLine()&#125; while (!&quot;#&quot;.equals(str))System.out.println(&quot;****game over****&quot;) for表达式 除了传统的循环遍历功能之外，还支持产生返回值 循环场景 1234567891011121314151617// 包含右边界for (i &lt;- 1 to 10) &#123;System.out.println(i)&#125;// 不包含右边界for (i &lt;- 1 until 10) &#123;System.out.println(i)&#125;// 遍历集合val list = List(&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;)for (i &lt;- list) &#123; System.out.println(i)&#125;// 双重循环for (i &lt;- 1 to 3; j &lt;- 1 until 3) &#123; System.out.printf(s&quot;i-&gt;$&#123;i&#125;,j=$&#123;j&#125;\\r\\n&quot;)&#125; 过滤数据 123456789101112131415161718// 单重循环for ( i &lt;- 1 to 100 if i % 3 == 0 if i % 5 == 0) &#123; System.out.println(i)&#125;// 多重循环for ( i &lt;- 1 to 3 if i % 3 == 0; j &lt;- 1 until 3 if i == 3 if j % 2 == 0) &#123; System.out.printf(s&quot;i-&gt;$&#123;i&#125;,j=$&#123;j&#125;\\r\\n&quot;)&#125; 中途变量绑定 12345678for &#123; i &lt;- 1 to 100 if i % 3 == 0 if i % 5 == 0 line = &quot;hello-&gt;&quot; + i&#125; &#123; System.out.println(line)&#125; 返回值for-yield模式 使用规则for-子句-yield-代码体 123456789val vector = for &#123; i &lt;- 1 to 100 if i % 3 == 0 if i % 5 == 0 line = &quot;hello-&gt;&quot; + i&#125; yield &#123; &quot;new-&quot; + line&#125;System.out.println(vector) try表达式 1、Scala不要求处理受检测的异常(checked exception)或则throws子句中声明。可以使用@throws来声明一个throw子句，但是不是必须的 2、跟Java一样，如果在finally中返回值或则抛出异常将会改变try或则catch中的返回值 3、Scala中支持返回值 普通try-catch 1234567891011try &#123; val a: Int = 10 val b: Int = 0 val c: Int = a / b&#125; catch &#123; case e: NullPointerException =&gt; System.out.println(e) case e: ArithmeticException =&gt; System.out.println(e) case e: Exception =&gt; System.out.println(e)&#125; finally &#123; System.out.println(&quot;finally&quot;)&#125; 返回值try-catch 12345678910111213141516171819val name = try &#123; val a: Int = 10 val b: Int = 0 if (a / b == 0) &quot;张三&quot; else &quot;李四&quot;&#125; catch &#123; case e: NullPointerException =&gt; &#123; System.out.println(e) &quot;NullPointerException&quot; &#125; case e: ArithmeticException =&gt; &#123; System.out.println(e) &quot;ArithmeticException&quot; &#125; case e: Exception =&gt; &#123; System.out.println(e) &quot;Exception&quot; &#125;&#125;System.out.println(name) throws声明异常 12345678@throws[ArithmeticException](&quot;除数为0&quot;)def sayHello(age: Int): String = &#123; if (age != null &amp;&amp; age &gt; 20) &#123; &quot;hello&quot; &#125; else &#123; if (age / Random.nextInt(3) == 1) &quot;张三&quot; else &quot;李四&quot; &#125;&#125; match表达式 1、与Java中的switch类似，但是不限制与Java中的整形、枚举、字符串常量。在Scala中任何字符串、常量都可以 2、支持返回值 123456789val msg = StdIn.readLine()val rtn = msg match &#123; case &quot;北京&quot; =&gt; &quot;北京&quot; case &quot;上海&quot; =&gt; &quot;上海&quot; case &quot;广州&quot; =&gt; &quot;广州&quot; case &quot;深圳&quot; =&gt; &quot;深圳&quot; case _ =&gt; &quot;其他&quot;&#125;System.out.println(rtn) 去掉了continue与break 在Scala中使用if来代替continue，布尔值来代替break 结合使用if 1234567891011var i: Integer = 1var find: Boolean = falsewhile (i &lt; 100 &amp;&amp; !find) &#123; if (i % 2 == 0) &#123; if (i % 20 == 0) &#123; find = true &#125; System.out.println(i) &#125; i = i + 1&#125; 使用scala.util.control.Breaks.breakable break方法其实是抛出了一个异常，由breakable进行捕获处理 123456789101112scala.util.control.Breaks.breakable &#123; var i: Integer = 1 while (i &lt; 100) &#123; if (i % 2 == 0) &#123; if (i % 20 == 0) &#123; scala.util.control.Breaks.break &#125; System.out.println(i) &#125; i = i + 1 &#125;&#125;","tags":[{"name":"控制结构","slug":"控制结构","permalink":"https://ceclar123.github.io/tags/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"}]}]