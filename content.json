[{"title":"Scala修饰符","date":"2019-10-24T02:29:00.000Z","path":"2019/10/24/【Scala】修饰符/","text":"Scala 访问修饰符基本和Java的一样，分别有：private，protected，public。但是一些细节不太一样。默认缺省情况下，Scala对象的访问级别是public。 不写（default）默认：包内可访问 private私有：类内可访问 protected保护：包内和子类可访问 public公有：都可访问 私有private 带有此标记的成员仅在包含了成员定义的类或对象内部可见 Scala中 123456789101112131415class ScalaOuter &#123; class ScalaInner &#123; private def hello() &#123; println(&quot;hello&quot;) &#125; class ScclaInnerInner &#123; hello() &#125; &#125; private def world(): Unit = &#123; (new ScalaInner).hello() //错误，方法不可见 &#125;&#125; Java中 123456789101112131415161718class JavaOuter &#123; class JavaInner &#123; private void hello() &#123; System.out.println(&quot;hello&quot;); &#125; class JavaInnerInner &#123; private void world() &#123; hello(); &#125; &#125; &#125; private void world() &#123; // Java中能够访问 new JavaInner().hello(); &#125;&#125; 保护protected 只允许保护成员在定义了该成员的的类的子类中被访问。而在Java中，用protected关键字修饰的成员，除了定义了该成员的类的子类可以访问，同一个包里的其他类也可以进行访问 Scala中 12345678910111213141516171819202122232425package a &#123; class ScalaOuter &#123; protected val helloWorld = &quot;Hello World&quot; protected def hello() &#123; println(&quot;hello&quot;) &#125; class ScalaInner &#123; hello() &#125; &#125;&#125;package b &#123; class ScalaOuterChild extends a.ScalaOuter &#123; hello() private def world(): Unit = &#123; hello() println(helloWorld) &#125; &#125;&#125; Java中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package a;public class JavaOuter &#123; protected String helloWorld = &quot;Hello World&quot;; protected void hello() &#123; System.out.println(&quot;hello&quot;); &#125;&#125;/* 子类中能和谐访问 */package b;import a.JavaOuter;public class JavaOuterChild extends JavaOuter &#123; private void world() &#123; this.hello(); System.out.println(helloWorld); &#125;&#125;/* 同一个包中，能和谐访问 */package a;public class JavaOuterSamePackage &#123; private void world() &#123; JavaOuter outer = new JavaOuter(); // 正常访问 outer.hello(); // 正常访问 System.out.println(outer.helloWorld); &#125;&#125;/* 不同包中，不能访问 */package b;import a.JavaOuter;public class JavaOuterDiffPackage &#123; private void world() &#123; JavaOuter outer = new JavaOuter(); // 不能访问 outer.hello(); // 不能访问 System.out.println(outer.helloWorld); &#125;&#125; 公共public 如果没有指定任何的修饰符，则默认为 public。这样的成员在任何地方都可以被访问 作用域保护","tags":[{"name":"修饰符","slug":"修饰符","permalink":"https://ceclar123.github.io/tags/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"}]},{"title":"Scala数据类型","date":"2019-10-23T12:29:00.000Z","path":"2019/10/23/【Scala】数据类型/","text":"Scala完全面向对象语法，像Java中的基本数据类型（例如：int）是没有。同时Java的包装类型（例如：Integer）在Scala中都有对应的类型，并且可以隐式转换。 数据类型 数据类型 描述 Byte 8位有符号补码整数。数值区间为 -128 到 127 Short 16位有符号补码整数。数值区间为 -32768 到 32767 Int 32位有符号补码整数。数值区间为 -2147483648 到 2147483647 Long 64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807 Float 32 位, IEEE 754 标准的单精度浮点数 Double 64 位 IEEE 754 标准的双精度浮点数 Char 16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF String 字符序列 Boolean true或false Unit 表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。 Null Null类是null引用对象的类型，它是每个引用类（继承自AnyRef的类）的子类。Null不兼容值类型 Nothing Nothing类型在Scala的类层级的最底端；它是任何其他类型的子类型。 Any Any是所有其他类的超类 AnyRef AnyRef类是Scala里所有引用类(reference class)的基类 AnyVal AnyVal是Scala里所有值类型的基类 类关系 Any AnyVal Byte Short Int Long Float Double Unit Char Boolean Scala.Nothing AnyRef Scala.Null Scala.Nothing 字面量 整形字面量 整型字面量用于 Int 类型，如果表示 Long，可以在数字后面添加 L 或者小写 l 作为后缀。Byte、Short需要显示声明并且不要越界 1234567891011121314151617val age1 = 1val age2 = 1Lval age3 = 0x1254512val age4 = 0x1254512Lval age5: Short = 100val age6: Byte = 12println(age1.getClass, age1)println(age2.getClass, age2)println(age3.getClass, age3)println(age4.getClass, age4)println(age5.getClass, age5)println(age6.getClass, age6)printf(&quot;Byte[%d,%d]\\n&quot;, Byte.MinValue, Byte.MaxValue)printf(&quot;Short[%d,%d]\\n&quot;, Short.MinValue, Short.MaxValue)printf(&quot;Int[%d,%d]\\n&quot;, Int.MinValue, Int.MaxValue)printf(&quot;Long[%d,%d]\\n&quot;, Long.MinValue, Long.MaxValue) 浮点型字面量 浮点型默认是Double类型，Float类型需要在数字后面加后缀F 12345678val price1 = 12.34val price2 = 12.34Fprintln(price1.getClass, price1)println(price2.getClass, price2)printf(&quot;Float[%f,%f]\\n&quot;, Float.MinValue, Float.MaxValue)printf(&quot;Double[%f,%f]\\n&quot;, Double.MinValue, Double.MaxValue) 布尔型字面量 12345val b1 = trueval b2 = falseprintln(b1.getClass, b1)println(b2.getClass, b2) 符号字面量 符号字面量被写成： ‘&lt;标识符&gt; ，这里 &lt;标识符&gt; 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例 属于基本类型，被映射成scala.Symbol 当两个Symbol值相等时，指向同一个实例 作为不可变的字符串，同时不必重复地为相同对象创建实例，节省资源 123456val s1 = &#x27;helloval s2 = scala.Symbol(&quot;hello&quot;)println(s1 == s2)println(s1.getClass, s1)println(s2.getClass, s2) 字符字面量 用单引号**’**来操作 12345678910111213val ch1 = &#x27;a&#x27;val ch2 = &#x27;\\u0041&#x27;val ch3 = &#x27;\\n&#x27;val ch4 = &#x27;\\t&#x27;val ch5 = &#x27;\\f&#x27;val ch6: Char = 97println(ch1.getClass, ch1)println(ch2.getClass, ch2)println(ch3.getClass, ch3)println(ch4.getClass, ch4)println(ch5.getClass, ch5)println(ch6.getClass, ch6) 字符串字面量 用双引号**”表示，多行字符串用三引号“””**表示 1234567val str1 = &quot;hello wolrd&quot;val str2 = &quot;&quot;&quot;hello 多行文本, 第二行文本， 第三行文本&quot;&quot;&quot;println(str1.getClass, str1)println(str2.getClass, str2) 转义字符 转义字符 Unicode 描述 \\b \\u0008 退格(BS) ，将当前位置移到前一列 \\t \\u0009 水平制表(HT) （跳到下一个TAB位置） \\n \\u000a 换行(LF) ，将当前位置移到下一行开头 \\f \\u000c 换页(FF)，将当前位置移到下页开头 \\r \\u000d 回车(CR) ，将当前位置移到本行开头 &quot; \\u0022 代表一个双引号(“)字符 &#39; \\u0027 代表一个单引号（’）字符 \\ \\u005c 代表一个反斜线字符 ‘&#39;","tags":[{"name":"数据类型","slug":"数据类型","permalink":"https://ceclar123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"Scala变量","date":"2019-10-21T03:29:00.000Z","path":"2019/10/21/【Scala】变量/","text":"在 Scala 中，使用关键词 var 声明变量，使用关键词 val 声明常量 变量声明 12var VariableName : DataType [&#x3D; Initial Value]val VariableName : DataType [&#x3D; Initial Value] 123var city: String = &quot;北京&quot;val age: Int = 10println(city, age) 类型推断 当分配一个初始值给一个变量，Scala编译器可以计算出根据分配给它的值的变量类型。 123var city1 = &quot;北京&quot;val city2 = &quot;上海&quot;println(city1, city2) 多个变量声明12345var city1, city2 = &quot;北京&quot;println(city1, city2)val user1, user2 = &quot;张三&quot;println(user1, user2) 变量与常量12345678910111213141516171819202122232425// var变量var city = &quot;北京&quot;city = &quot;上海&quot;println(city)// val常量val user = &quot;张三&quot;// 不能重新赋值//user = &quot;李四&quot;println(user)// 有一种特殊场景，虽然不能重新对val变量userInfo赋值，但是可以修改里面的内容class UserInfo(var userName: String, var age: Int) &#123; override def toString: String = &#123; s&quot;$&#123;userName&#125;,$&#123;age&#125;&quot; &#125;&#125;val userInfo: UserInfo = new UserInfo(&quot;李四&quot;, 20)// 不能重新赋值//userInfo = new UserInfo(&quot;李四&quot;, 20)//修改内容userInfo.userName = &quot;张三&quot;userInfo.age = 10println(userInfo)","tags":[{"name":"变量","slug":"变量","permalink":"https://ceclar123.github.io/tags/%E5%8F%98%E9%87%8F/"}]},{"title":"Scala基础","date":"2019-10-20T06:29:00.000Z","path":"2019/10/20/【Scala】基础/","text":"Scala是一种纯面向对象的语言，每个值都是对象。基于JVM，兼容现有的Java程序。对于有Java基础的很容易掌握，同时有一些细节也需要特别关注。 注意事项 大小写敏感，与Java一样 类名，首字母大写，单词首字母大写，与Java一样 123class HelloWorld &#123; //&#125; 方法名称，首字母小写，单词首字母大写，与Java一样 12345class HelloWorld &#123; def sayHello(txt: String): Unit = &#123; println(s&quot;hello $&#123;txt&#125;&quot;) &#125;&#125; 文件名称，程序文件的名称应该与对象名称完全匹配(新版本不需要了) 标识符 用于对象，类，变量和方法的名称称为标识符。关键字不能用作标识符，标识符区分大小写。 字母数字标识符 以字母或下划线开始，之后可以跟字母、数字或下划线 $字符也被当作是字母，但被保留作为scala编译器产生的标识符之用。用户程序里的标识符不应该包含$字符，尽管能够编译通过，最好不要这样用 Scala遵循java的驼峰式标识符习惯，尽管下划线在标识符内是合法的，但最好不要这样用，因为在Scala中有其他用法。 运算符标识符 由一个或多个符号组成，例如： 1+ ++ ::: &lt; ?&gt; :-&gt; Scala编译器将在内部将操作符标识符转换成具有嵌入式$字符的合法Java标识符。例如，标识符:-&gt;将被内部表示为$colon$minus$greater 混合标识符 由字母数字组成，后面跟着下划线和一个操作符标识符 123val user_+ = &quot;张三&quot;val user_# = &quot;李四&quot;println(user_+, user_#) 字面识别符 文字标识符是用反引号`括起来的任意字符串，即使scala保留字，这个规则也有效 1234val `province` = &quot;四川&quot;val `object` = &quot;成都&quot;println(`province`, `object`)// 在 Scala 中 Thread. yield()非法的，因为 yield 是保留字。但是可以这样调用：Thread.`yield`() 注释 与Java类似，支持单行与多行注释，多行注释注意嵌套 1234567891011121314151617/** 这里是多行注释* /*多行注意嵌套*/*/val hello = &quot;hello&quot;// 单行注释1// 单行注释2var world = &quot;world&quot;/*** 文档注释** @param args 参数*/def main(args: Array[String]): Unit = &#123; //&#125; 换行符 Scala是面向行的语言，语句可以用分号（;）结束或换行符 语句末尾的分号通常是可选的。如果一行里仅 有一个语句可不写。如果一行里写多个语句那么分号是必需的 12val a = &quot;张三&quot;val b = &quot;张三&quot;; val c = &quot;李四&quot; 关键字 abstract case catch class def do else extends false final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try true type val var while with yield - : = =&gt; &lt;- &lt;: &lt;% &gt;: # @","tags":[{"name":"语法","slug":"语法","permalink":"https://ceclar123.github.io/tags/%E8%AF%AD%E6%B3%95/"},{"name":"基础","slug":"基础","permalink":"https://ceclar123.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}]